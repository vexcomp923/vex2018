#pragma config(Sensor, dgtl1,  InputUltraRight, sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  InputUltraLeft, sensorSONAR_inch)
#pragma config(Motor,  port1,           stacker,       tmotorNone, openLoop)
#pragma config(Motor,  port2,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           arms,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armss,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           mobileLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



//*distance between the robot's starting position and the nearest mobile goal is 54.23 inches



int p = 0;

int t = 0;

int r = 0;

int l = 0;





/*void moveForward (int p, int t, int r, int l)

23 {

24 while (p < 3)

25 {

26 motor[backLeft] = 63 + t*l;

27 motor [backRight] = 63 + t*r;

28 motor [frontLeft] = 63 + t*l;

29 motor [frontRight] = 63 + t*r;

30 wait1Msec(5000);

31 p++;.

32 }

33 }*/









task startUltra ()

{

	while (true)

	{

		resetMotorEncoder(backLeft);

		resetMotorEncoder(frontLeft);

		resetMotorEncoder(backRight);

		resetMotorEncoder(frontRight);





		if (SensorValue[InputUltraRight] == 6 || SensorValue[InputUltraRight] == -1)

		{

			t = 0;

			r = 0;

			l = 0;

			//			motor[backLeft] = 63;

		}

		else if (SensorValue[InputUltraRight] < 6)

		{

			t = 20;

			r = 0;

			l = 1;

			//			motor[backLeft] = 63 + 20;

		}

		else if(SensorValue[InputUltraRight] > 6)

		{

			t = 20;

			r = 1;

			l = 0;

			//			motor[backLeft] = 50;

		}

		wait1Msec (15);





	}





}









task startUltraRev ()

{

	while (true)

	{

		resetMotorEncoder(backLeft);

		resetMotorEncoder(frontLeft);

		resetMotorEncoder(backRight);

		resetMotorEncoder(frontRight);





		if (SensorValue[InputUltraLeft] == 6 || SensorValue[InputUltraRight] == -1)

		{

			t = 0;

			r = 0;

			l = 0;

			//			motor[backLeft] = 63;

		}

		else if (SensorValue[InputUltraLeft] < 6)

		{

			t = 40;

			r = 0;

			l = 1;

			//			motor[backLeft] = 63 + 20;

		}

		else if(SensorValue[InputUltraLeft] > 6)

		{

			t = 40;

			r = 1;

			l = 0;

			//			motor[backLeft] = 50;

		}

		wait1Msec (15);





	}





}



/*---------------------------------------------------------------------------*/

/*                                                                           */

/*        Description: Competition template for VEX EDR                      */

/*                                                                           */

/*---------------------------------------------------------------------------*/



// This code is for the VEX cortex platform

#pragma platform(VEX2)





// Select Download method as "competition"

#pragma competitionControl(Competition)





//Main competition background code...do not modify!

#include "Vex_Competition_Includes.c"





/*---------------------------------------------------------------------------*/

/*                          Pre-Autonomous Functions                         */

/*                                                                           */

/*  You may want to perform some actions before the competition starts.      */

/*  Do them in the following function.  You must return from this function   */

/*  or the autonomous and usercontrol tasks will not be started.  This       */

/*  function is only called once after the cortex has been powered on and    */

/*  not every time that the robot is disabled.                               */

/*---------------------------------------------------------------------------*/





void pre_auton()

{

	// Set bStopTasksBetweenModes to false if you want to keep user created tasks

	// running between Autonomous and Driver controlled modes. You will need to

	// manage all user created tasks if set to false.

	bStopTasksBetweenModes = true;





	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD

	// used by the competition include file, for example, you might want

	// to display your team name on the LCD in this function.

	// bDisplayCompetitionStatusOnLcd = false;





	// All activities that occur before the competition starts

	// Example: clearing encoders, setting servo positions, ...

}



/*---------------------------------------------------------------------------*/

/*                                                                           */

/*                              Autonomous Task                              */

/*                                                                           */

/*  This task is used to control your robot during the autonomous phase of   */

/*  a VEX Competition.                                                       */

/*                                                                           */

/*  You must modify the code to add your own robot specific commands here.   */

/*---------------------------------------------------------------------------*/





task autonomous()

{





	//short backLeftAdjust;









	startTask (startUltra);





	while (p < 5)

	{

		motor[backLeft] = 40 + t*r;

		motor [backRight] = 40 + t*l;

		motor [frontLeft] = 40 + t*r;

		motor [frontRight] = 40 + t*l;

		wait1Msec(15);

		p++;

	}





	stopTask(startUltra);



	motor [arms] = 127;

	wait1Msec(500);

	motor [arms] = 0;



	motor [mobileLift] = 127;

	wait1Msec(4300);

	motor [mobileLift] = 0;

	wait1Msec(100);





	motor [mobileLift] = -127;

	wait1Msec(2000);

	motor [mobileLift] = 0;

	wait1Msec(1000);





	motor[backLeft] = -63;

	motor [backRight] = -63;

	motor [frontLeft] = -63;

	motor [frontRight] = -63;

	wait1Msec(8000);

	motor[backLeft] = 0;

	motor [backRight] = 0;

	motor [frontLeft] = 0;

	motor [frontRight] = 0;

	wait1Msec(500);





	motor[backLeft] = 63;

	motor [backRight] = -63;

	motor [frontLeft] = 63;

	motor [frontRight] = -63;

	wait1Msec(2000);

	motor[backLeft] = 0;

	motor [backRight] = 0;

	motor [frontLeft] = 0;

	motor [frontRight] = 0;





	startTask (startUltraRev);





	while (p < 50)

	{

		motor[backLeft] = 63 + t*l;

		motor [backRight] = 63 + t*r;

		motor [frontLeft] = 63 + t*l;

		motor [frontRight] = 63 + t*r;

		wait1Msec(15);

		p++;

	}





	motor [mobileLift] = 127;

	wait1Msec(2000);

	motor [mobileLift] = 0;

	wait1Msec(500);





	motor [mobileLift] = -127;

	wait1Msec(500);

	motor [mobileLift] = 0;

	wait1Msec(500);





	motor[backLeft] = 63;

	motor [backRight] = 63;

	motor [frontLeft] = 63;

	motor [frontRight] = 63;

	wait1Msec(500);

	motor[backLeft] = 0;

	motor [backRight] = 0;

	motor [frontLeft] = 0;

	motor [frontRight] = 0;

	wait1Msec(500);





	stopTask (startUltraRev);









	/*motor[mobileLift] = 127;

	248 	wait1Msec(1000);

	249

	250 	motor [frontLeft] = 127;

	251 	motor [frontRight] = 127;

	252 	motor [backLeft] = 127;

	253 	motor [backRight] = 127;

	254 	wait1Msec(500);

	255

	256 	motor[mobileLift] = -127;

	257 	wait1Msec(1000);

	258

	259 	motor [frontLeft] = 127;

	260 	motor [frontRight] = 127;

	261 	motor [backLeft] = 127;

	262 	motor [backRight] = 127;

	263 	wait1Msec(500);

	264

	265 	startTask (startUltra);

	266

	267 	motor [mobileLift] = 127;

	268 	wait1Msec(500);

	269 	motor [mobileLift] = -127;

	270 	wait1Msec(500);

	271

	272

	273

	274

	275

	276

	277 	/*wait1Msec(2000);

	278

	279 	resetMotorEncoder(backLeft);

	280 	resetMotorEncoder(frontLeft);

	281 	resetMotorEncoder(backRight);

	282 	resetMotorEncoder(frontRight);

	283 	wait1Msec(2000);

	284

	285 	motor [backLeft] = 550;

	286 	wait1Msec(2000);

	287

	288 	if(getMotorEncoder(backLeft) > 500 &&	(getMotorEncoder(backLeft) < 7000))

	289 	{

	290 	motor[backLeft] = 63;

	291 	motor[frontLeft] = 63;

	292 	motor[backRight] = 63;

	293 	motor[frontRight] = 63;

	294 	wait1Msec(2000);

	295 	}

	296 	if (SensorValue[InputUltra] < 12)

	297 	{

	298 	backLeftAdjust = 50;

	299 	}

	300 	else

	301 	{

	302 	backLeftAdjust = 0;

	303 	}

	304 	if(getMotorEncoder(backLeft) > 7000)

	305 	{

	306 	motor[backLeft] = 0 + backLeftAdjust;

	307 	motor[frontLeft] = 0 + backLeftAdjust;

	308 	motor[backRight] = 0 + backLeftAdjust;

	309 	motor[frontRight] = 0 + backLeftAdjust;

	310 	wait1Msec(2000);

	311 	}*/





	//this is just a reference point for the rest of the program

}





/*---------------------------------------------------------------------------*/

/*                                                                           */

/*                              User Control Task                            */

/*                                                                           */

/*  This task is used to control your robot during the user control phase of */

/*  a VEX Competition.                                                       */

/*                                                                           */

/*  You must modify the code to add your own robot specific commands here.   */

/*---------------------------------------------------------------------------*/





task usercontrol()

{

	bLCDBacklight = true;                                    // Turn on LCD Backlight

	string mainBattery;//, backupBattery;





	while (true)

	{

		/*if(vexRT[Ch1]>5)

		334 		{

		335 		motor[backLeft] = 127;

		336 		motor[frontLeft] = 127;

		337 		motor[backRight] = -127;

		338 		motor[frontRight] = -127;

		339 		}*/









		if (vexRT[Ch2]>10)

		{

			motor[backRight] = 127;

			motor[frontRight] = 127;

		}





		else if (vexRT[Ch2]<-10)

		{

			motor[backRight] = -127;

			motor[frontRight] = -127;

		}

		else

		{

			motor[backRight] = 0;

			motor[frontRight] = 0;

		}

		/*if(vexRT[Ch4]>5)

		359 		{

		360 		motor[backRight] = 127;

		361 		motor[frontRight] = 127;

		362 		motor[backLeft] = -127;

		363 		motor[frontLeft] = -127;

		364 		}*/

		if (vexRT[Ch3]>10)

		{

			motor [backLeft] = 127;

			motor [frontLeft] = 127;

		}





		else if (vexRT[Ch3]<-10)

		{

			motor[backLeft] = -127;

			motor[frontLeft] = -127;

		}

		else

		{

			motor[backLeft] = 0;

			motor[frontLeft] = 0;

		}

		//this code control moving fwd and bkwd









		/*if(vexRT[Ch4]>5)

		385 		{

		386 		motor[backRight] = -127;

		387 		motor[frontRight] = 127;

		388 		}

		389 		else if (vexRT[Ch4]<-5)

		390 		{

		391 		motor [backRight] = 127;

		392 		motor [frontRight] = -127;

		393 		}

		394 		/*

		395 		/*if (vexRT[Ch1]>5)

		396 		{

		397 		motor [backLeft] = 127;

		398 		motor [frontLeft] = -127;

		399 		}

		400 		else if (vexRT[Ch1]<-5)

		401 		{

		402 		motor [backLeft] = -127;

		403 		motor [frontLeft] = 127;

		404 		}*/

		//this code controls strafing right and left





		if (vexRT[Btn5DXmtr2] == 1)

		{

			motor [frontLeft] = 0;

			motor [frontRight] = 0;

			motor [backLeft] = 0;

			motor [backRight] = 0;

			motor [arms] = 0;

			motor [claw] = 0;

			motor [armss] = 0;

			motor [stacker] =0;

			motor [mobileLift]=0;





		}

		if (vexRT[Btn5D] == 1)

		{

			motor [frontLeft] = 0;

			motor [frontRight] = 0;

			motor [backLeft] = 0;

			motor [backRight] = 0;

			motor [arms] = 0;

			motor [claw] = 0;

			motor [armss] = 0;

			motor [stacker] =0;

			motor [mobileLift]=0;





		}

		//this was programmed by Vaishnavi

		//so that each channel can do many things

		//thanks!





		/*if (vexRT[Btn7U] == 1)

		438 		{

		439 		motor [frontLeft] = 127;

		440 		motor [backLeft] = 127;

		441 		motor [frontRight] = 127;

		442 		motor [backRight] = 127;

		443 		}

		444 		else if (vexRT[Btn7D] == 1)

		445 		{

		446 		motor [frontLeft] = -127;

		447 		motor [backLeft] = -127;

		448 		motor [frontRight] = -127;

		449 		motor [backRight] = -127;

		450 		}

		451 		else

		452 		{

		453 		motor [frontLeft] = 0;

		454 		motor [backLeft] = 0;

		455 		motor [frontRight] = 0;

		456 		motor [backRight] = 0;

		457 		}*/









		if (vexRT[Btn8U] == 1)

		{

			motor [claw] = 127;

		}

		else if (vexRT [Btn8D] == 1)

		{

			motor [claw] = -127;

		}

		else

		{ //Hi Vaibhavi, try setting this number to different values. This will be your default value when you are not pressing any buttons.

			motor [claw] = -20;

		}









		if (vexRT[Btn6DXmtr2] == 1)

		{

			motor [arms] = 127;

			motor [armss] = 127;

		}

		else if (vexRT [Btn6UXmtr2] == 1)

		{

			motor [arms] = -127;

			motor [armss] =-127;

		}

		else

		{

			motor [arms] = -30;

			motor [armss] = -30;

		}









		if (vexRT[Btn7RXmtr2] == 1)

		{

			motor [mobileLift] = 127;

		}

		else if (vexRT[Btn7LXmtr2] == 1)

		{

			motor [mobileLift] = -127;

		}

		else

		{

			motor [mobileLift] = 0;

		}





		if (vexRT[Btn8RXmtr2] == 1)

		{

			motor [stacker] = 127;

		}

		else if (vexRT[Btn8LXmtr2] == 1)

		{

			motor [stacker] = -127;

		}

		else

		{ //Hi Vaibhavi, try setting this number to different values. This will be your default value when you are not pressing any buttons.

			motor [stacker] = 20;

		}









		clearLCDLine(0);                                            // Clear line 1 (0) of the LCD

		//clearLCDLine(1);                                            // Clear line 2 (1) of the LCD





		//Display the Primary Robot battery voltage

		displayLCDString(0, 0, "Primary: ");

		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed

		displayNextLCDString(mainBattery);





		//Display the Backup battery voltage

		//displayLCDString(1, 0, "Backup: ");

		//sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed

		//displayNextLCDString(backupBattery);





		//Short delay for the LCD refresh rate

		wait1Msec(10);

	}

}
